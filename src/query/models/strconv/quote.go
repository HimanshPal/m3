// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package strconv

import (
	"strconv"
	"unicode/utf8"
)

// NB: predefined strconv constants
const (
	tx = 0x80 // 1000 0000
	t2 = 0xC0 // 1100 0000
	t3 = 0xE0 // 1110 0000
	t4 = 0xF0 // 1111 0000

	maskx = 0x3F // 0011 1111

	rune1Max = 1<<7 - 1
	rune2Max = 1<<11 - 1
	rune3Max = 1<<16 - 1

	runeError = '\uFFFD'     // the "error" Rune or "Unicode replacement character"
	maxRune   = '\U0010FFFF' // Maximum valid Unicode code point.

	// NB: Code points in the surrogate range are not valid for UTF-8.
	surrogateMin = 0xD800
	surrogateMax = 0xDFFF

	lowerhex = "0123456789abcdef"

	quote = byte('"')
)

// EncodeRune writes into src (which must be large enough) the UTF-8 encoding
// of the rune at the given index. It returns the number of bytes written.
func encodeRune(dst []byte, r rune) int {
	// Negative values are erroneous. Making it unsigned addresses the problem.
	switch i := uint32(r); {
	case i <= rune1Max:
		dst[0] = byte(r)
		return 1
	case i <= rune2Max:
		dst[1] = tx | byte(r)&maskx
		dst[0] = t2 | byte(r>>6)
		return 2
	case i > maxRune, surrogateMin <= i && i <= surrogateMax:
		r = runeError
		fallthrough
	case i <= rune3Max:
		dst[2] = tx | byte(r)&maskx
		dst[0] = t3 | byte(r>>12)
		dst[1] = tx | byte(r>>6)&maskx
		return 3
	default:
		dst[3] = tx | byte(r)&maskx
		dst[0] = t4 | byte(r>>18)
		dst[1] = tx | byte(r>>12)&maskx
		dst[2] = tx | byte(r>>6)&maskx
		return 4
	}
}

// It returns the number of bytes written.
func insertEscapedRune(dst []byte, r rune) int {
	if r == rune(quote) || r == '\\' { // always backslashed
		dst[1] = byte(r)
		dst[0] = '\\'
		return 2
	}

	if strconv.IsPrint(r) {
		return encodeRune(dst, r)
	}

	switch r {
	case '\a':
		dst[1] = 'a'
		dst[0] = '\\'
		return 2
	case '\b':
		dst[1] = 'b'
		dst[0] = '\\'
		return 2
	case '\f':
		dst[1] = 'f'
		dst[0] = '\\'
		return 2
	case '\n':
		dst[1] = 'n'
		dst[0] = '\\'
		return 2
	case '\r':
		dst[1] = 'r'
		dst[0] = '\\'
		return 2
	case '\t':
		dst[1] = 't'
		dst[0] = '\\'
		return 2
	case '\v':
		dst[1] = 'v'
		dst[0] = '\\'
		return 2
	default:
		switch {
		case r < ' ':
			dst[3] = lowerhex[byte(r)&0xF]
			dst[0] = '\\'
			dst[1] = 'x'
			dst[2] = lowerhex[byte(r)>>4]
			return 4
		case r > utf8.MaxRune:
			r = 0xFFFD
			fallthrough
		case r < 0x10000:
			dst[5] = lowerhex[r>>uint(0)&0xF]
			dst[0] = '\\'
			dst[1] = 'u'
			dst[2] = lowerhex[r>>uint(12)&0xF]
			dst[3] = lowerhex[r>>uint(8)&0xF]
			dst[4] = lowerhex[r>>uint(4)&0xF]
			return 6
		default:
			dst[9] = lowerhex[r>>uint(0)&0xF]
			dst[0] = '\\'
			dst[1] = 'U'
			dst[2] = lowerhex[r>>uint(28)&0xF]
			dst[3] = lowerhex[r>>uint(24)&0xF]
			dst[4] = lowerhex[r>>uint(20)&0xF]
			dst[5] = lowerhex[r>>uint(16)&0xF]
			dst[6] = lowerhex[r>>uint(12)&0xF]
			dst[7] = lowerhex[r>>uint(8)&0xF]
			dst[8] = lowerhex[r>>uint(4)&0xF]
			return 10
		}
	}
}

// Quote copies byte slice src to dst at a given index, adding
// quotation runes around, src, and escaping any control
// characters. It returns the index at which the copy finished.
//
// NB: ensure that dst is large enough to store src, additional
// quotation runes, and any additional escape characters.
// as generated by Quote, to dst and returns the extended buffer.
func Quote(dst, src []byte) int {
	dst[0] = quote
	idx := 1
	indexedDst := dst[idx:]
	for width := 0; len(src) > 0; src = src[width:] {
		r := rune(src[0])
		width = 1
		if r >= utf8.RuneSelf {
			r, width = utf8.DecodeRune(src)
		}

		if width == 1 && r == utf8.RuneError {
			indexedDst[3] = lowerhex[src[0]&0xF]
			indexedDst[0] = '\\'
			indexedDst[1] = 'x'
			indexedDst[2] = lowerhex[src[0]>>4]
			idx += 4
			continue
		}

		idx += insertEscapedRune(indexedDst, r)
		indexedDst = dst[idx:]
	}

	dst[idx] = quote
	return idx + 1
}

// QuotedLength computes the length required for a byte slice to hold
// a quoted byte slice.
func QuotedLength(src []byte) int {
	length := 2 // initialize length to account for opening and closing quotes
	for width := 0; len(src) > 0; src = src[width:] {
		r := rune(src[0])
		width = 1
		if r >= utf8.RuneSelf {
			r, width = utf8.DecodeRune(src)
		}

		if width == 1 && r == utf8.RuneError {
			length += 4
			continue
		}

		length += escapedRuneLength(r)
	}

	return length
}

func escapedRuneLength(r rune) int {
	if r == rune(quote) || r == '\\' { // always backslashed
		return 2
	}

	if strconv.IsPrint(r) {
		switch i := uint32(r); {
		case i <= rune1Max:
			return 1
		case i <= rune2Max:
			return 2
		case i > maxRune, surrogateMin <= i && i <= surrogateMax:
			fallthrough
		case i <= rune3Max:
			return 3
		default:
			return 4
		}
	}

	switch r {
	case '\a':
		return 2
	case '\b':
		return 2
	case '\f':
		return 2
	case '\n':
		return 2
	case '\r':
		return 2
	case '\t':
		return 2
	case '\v':
		return 2
	default:
		switch {
		case r < ' ':
			return 4
		case r > utf8.MaxRune:
			fallthrough
		case r < 0x10000:
			return 6
		default:
			return 10
		}
	}
}
